<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <title>Блог компании Яндекс</title>
    <meta http-equiv="content-type" content="text/html">
    <meta description="блог" author="Vita">
    <!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">-->
        
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <style>
        article {
            margin-right: 340px;
            display: block;
            background: #DCDCDC;
            float: left;
        }

        aside {
            background: #FAF0E6;
            padding: 10px;
            width: 400px;
            float: left;
        }

        .clear {
            clear: left;
            /* Отмена обтекания */
        }

        li {
            list-style-type: none;
        }

        li:before {
            content: "* ";
            /* Добавляем в качестве маркера символ */
        }

        .spisok li:before {
            content: "- ";
            /* Добавляем в качестве маркера символ */
        }

        .spisok1 li:before {
            content: " ";
            /* Добавляем в качестве маркера символ */
        }

        
   abbr {
    border-bottom: 1px dashed red; /* Пунктирное подчеркивание текста */
    color: #000080; /* Темно-синий цвет текста */
   }
    </style>
</head>

<body>

    <header>
        <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
        <h4>
            <p>
                Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
                какой он красивый, ни то, какой он удобный. Никому не понравится, когда все
                тормозит.</p>
            <p>Мы регулярно добавляем в Яндекс. Почту новую функциональность,
                иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
                и новая логика. </p>
            <p>Всё это напрямую влияет на скорость работы интерфейса.</p>
        </h4>
    </header>
    <main>
        <section>
            <article>
                <h2>Что мы измеряем </h2>

                <p> Этапы первой загрузки:<p>
                        <ul>
                            <li>подготовка;</li>
                            <li>загрузка статики (<abbr title = "HyperText Transfer Protocol — протокол передачи гипертекста">HTTP</abbr>-запрос и парсинг);</li>
                            <li>исполнение модулей;</li>
                            <li>инициализация базовых объектов;</li>
                            <li>отрисовка. </li>
                        </ul>
                        <p>Этапы отрисовки любой страницы:</p>
                        <ul>
                            <li>подготовка к запросу на сервер;</li>
                            <li>запрос данных с сервера;</li>
                            <li>шаблонизация;</li>
                            <li>обновление <abbr title="Document Object Model — объектная модель документа">DOM</abbr>.</li>
                        </ul>
            </article>
            <aside>
                <p> — «Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы</p>
                <p>— «Что же дальше?» - вопрошаете вы</p>
                <p>— «А давай построим график!» - отвечаем мы</p>
                <p>— «А что будем считать?» - уточняете вы</p>
            </aside>

            <article>

                <p>Как вы знаете, медиана – это серединное, а не среднее значение в выборке.
                    Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
                    В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>

                <p> В случае ускорения или замедления медиана, конечно, изменится. Но она не может
                    рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>

                <p> <abbr title="Application Performance Index — индекс производительности приложений">APDEX</abbr> – метрика, которая сразу говорит: хорошо или плохо. Метрика
                    работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
                    время показа страницы попало в него, то пользователь счастлив. Берем еще один
                    интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
                    показана за это время, то пользователь в целом удовлетворен скоростью работы,
                    но уже не настолько счастлив. И применяем формулу:</p>
                <center>
                    <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).</p>
                </center>
                <p>Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
                    хорошо или плохо работает почта.</p>
            </article>

            <article>
                <h2> Как мы измеряем</h2>

                <p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
                    причину замедления: медленнее стал отвечать сервер либо слишком долго
                    выполняется JavaScript. Выглядит это примерно так:</p>
                <center>
                    this.timings['look-ma-im-start'] = Date.now();
                    this.timings['look-ma-finish'] = Date.now();</center>


                <p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при
                    отправке рассчитываются. На этапах разница между “end” и “start” не считается,
                    а все вычисления производятся в конце:</p>
                <center>
                    var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</center>

                <p>И на сервер прилетают подобные записи:</p>
                <center>
                    serverResponse=50&domUpdate=60</center>

                <h2> Как мы ускоряем </h2>

                <p> Чтобы снизить время загрузки почты при выходе новых версий,
                    мы уже делаем следующее:</p>
                <ul>
                    <li>включаем gzip;</li>
                    <li>выставляем заголовки кэширования;</li>
                    <li>фризим CSS, JS, шаблоны и картинки;</li>
                    <li>используем <abbr title="сокращение от content delivery network т.е. сеть доставки контента">CDN</abbr>;</li>
                </ul>
                <p> Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой
                    передавать только diff между ней и той, которая сохранена у пользователя?»
                    В браузере же останется просто наложить патч на клиенте.</p>
                <p>
                    На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,
                    RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
                    не получили должного распространения в браузерах и на серверах.</p>
                <p>
                    Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,
                    начали искать реализации diff на JS. На популярных хостингах кода нашли
                    библиотеки:</p>
                <div class="spisok">
                    <ul>
                        <li>VCDiff</li>
                        <li>google-diff-patch-match</li>
                    </ul>
                    <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
                    <table cellspacing="2" border="1" cellpadding="5">
                        <tr>
                            <th>Библиотека</th>
                            <th>IE 9 </th>
                            <th>Opera 12</th>
                        </tr>
                        <tr>
                            <td> vcdiff </td>
                            <td>8</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td> google diff </td>
                            <td>1363</td>
                            <td>76</td>
                        </tr>

                    </table>
                </div>
                <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
                    где и как хранить статику на клиенте.</p>
</article><article>
                <b>Формат файла с патчами для проекта выглядит так:</b>

                <pre>
                                [
                                {
                                "k": "jane.css",
                                "p": [patch],
                                "s": 4554
                                },
                                {
                                "k": "jane.css",
                                "p": [patch],
                                "s": 4554
                                }
                                ]
                                </pre>

                <p>
                    То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
                    каждого объекта есть три свойства.<p> k — названия ключа в localStorage для этого
                        ресурса.</p>
                    <p> p — патч для ресурса, который сгенерировал vcdiff.</p>
                    <p>s — чексумма для
                        ресурса актуальной версии, чтобы потом можно было проверить правильность
                        наложения патча на клиенте.</p>
                   <dl>
                     <p>Чексумма вычисляется по алгоритму Флетчера.</p>
           <dt>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dt>
                <dd>
                    — итерационный метод численной оптимизации, предназначенный для
                    нахождения локального максимума/минимума нелинейного функционала
                    без ограничений.</dd>
                </dl>
                    <p>

                    дано \({ε,x_0}\) <br>
                    инициализация \({H_0}\) <br>
                    \(k = 0\)<br>
                    <b> while</b> || \({\nabla\cdot} f_x\)||>ε <br>
                    найти направление \({p_k =- C_k \nabla\cdot f_x}\)<br>
                    вычислить \({ {x}_{k+1} = x_k + α_k p_k,&nbsp; α_k }\)удовлетворяет условиям Вольфе <br>
                    обозначить \({s_k = {x}_{k+1} - x_k &nbsp;и &nbsp;&#160; y_k=\nabla\cdot {f}_{k+1} - \nabla\cdot f_x}\) <br>
                    вычислить \({ {С}_{k+1}}\) <br>
                    \(k = k+1\) <br>
                    <b> end</b>

                </p>

                <p> Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p>
                <div class="spisok1">
                    <ul>
                        <li>6/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки
                            целостности данных</li>
                        <li>128-битный алгоритм хеширования, предназначен для создания «отпечатков»
                            или дайджестов сообщения произвольной длины и последующей проверки
                            их подлинности.</li>
                    </ul>
                </div>
                <p>потому что он быстрый, компактный и легок в реализации.</p>
                <h2>Итог</h2>

                Фактически мы экономим 80-90% трафика. Размер загружаемой статиcтики в байтах:

                <table cellspacing="2" border="1" cellpadding="5">
                    <tr>
                        <th>Релиз</th>
                        <th>С патчем </th>
                        <th>Без патча</th>
                    </tr>
                    <tr>
                        <td> 7.7.20 </td>
                        <td>397</td>
                        <td>174 549</td>
                    </tr>
                    <tr>
                        <td> 7.7.21 </td>
                        <td>383</td>
                        <td>53 995</td>
                    </tr>
                    <tr>
                        <td> 7.7.22 </td>
                        <td>483</td>
                        <td>3 995</td>
                    </tr>

                </table>

            </article>
        </section>

    </main>
    <footer>
        <aside>
            <adress>
                <p>Автор: @doochik</p>
                <p>С++ разработик</p>
                <p>Электронная почта: (doochik@yandex-team.ru)</p>
                <p>Компания: Яндекс</p>

            </adress>
        </aside>
        <article>
            <p>Комментарии (3):</p>

            <p> - Mogaika <cite>(mogaika@yandex-team.ru)</cite> 30 ноября 2014 в 17:05 </p>

            <p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p>

           <p> - JIguse <cite>(mrawesome@yandex.ru)</cite> 29 ноября 2014 в 21:30</p>

            <p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
                подробностями о внутренней работе сервисов.</p>

           <p> - Brister <cite>(brist89@yandex-team.ru)</cite><time datetime="2014-11-30T17:05:00+07:00">30 ноября 2014 в 17:05</time> 24 ноября 2014 в 13:13</p>

            <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
                Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
                хорошо или плохо работает почта.</p>

            <p>наверное все-таки от 0.5 до 1</p>

            <p>- alexeimois <cite>(test@yandex.ru)</cite> 22 ноября 2014 в 17:35</p>
        </article>
        <aside>
            <address>
                <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:</p>
                <p>help.yandex.ru/metrika/reports/monitoring_timing.xml</p>

                <p>© Яндекс, help@yandex.ru, Хохрякова, 10</p>
            </address>
        </aside>
    </footer>
</body>

</html>
